chill$spp <- paste(chill$genus, chill$species, sep="_")
chill.ws <- chill[(chill$method=="1"),]
chillmod <- brm(chill.ws ~ urban + (urban | species), data=chill.ws)
chill.ws <- chill[(chill$method=="1"),]
chillmod <- brm(chill.ws ~ urban + (urban | species), data=chill.ws)
View(chill.ws)
chillmod <- brm(chill.ws ~ urban + (urban | spp), data=chill.ws)
chillmod <- brm(utah ~ urban + (urban | spp), data=chill.ws)
chillmod
############################################################################
####################### CHILL TIME WITH AN INTERACTION!! ###################
#  1) Let's make the observations much higher than the actual data to build a good model.
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 600,
urban.coef = -200,
method.coef = 100,
urbanxmethod = 20)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", names.temp) # remove text to align with colnames
env.pairs <- sapply(1:length(interact.regex), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
####################### NOW LET'S ADD AN INTERACTION!! #####################
### Okay, now let's make some fake data using help Rethinking, Gelman, OSPREE and Geoff
#  1) Let's make the observations much higher than the actual data to build a good model.
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 400,
urban.coef = -50,
method.coef = -100,
urbanxmethod = 10)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", names.temp) # remove text to align with colnames
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(interact.regex), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
############################################################################
####################### CHILL TIME WITH AN INTERACTION!! ###################
#  1) Let's make the observations much higher than the actual data to build a good model.
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 600,
urban.coef = -200,
method.coef = 100,
urbanxmethod = 20)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", intrxname) # remove text to align with colnames
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
# Create model matrix
mm <- model.matrix(~env.samples2)
#  4) We need to make a random intercept model for each species
parameters.temp <- matrix(unlist(model.parameters), ncol = length(model.parameters), nrow = nsp * ntot, byrow = TRUE)
# Which parameters are random?
random.regex <- grep(pattern = paste(c("intercept", "urban.coef", "method.coef", "urbanxmethod"), collapse = "|"), x = names(model.parameters))
# Generate random parameters (by species)
parameters.temp[, 1] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[1]]], sd = 100), ntot)})
parameters.temp[, 2] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[2]]], sd = 50), ntot)})
parameters.temp[, 3] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[3]]], sd = 20), ntot)})
parameters.temp[, 4] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[4]]], sd = 10), ntot)})
# Calculate response
response <- sapply(1:nrow(env.samples), FUN = function(x){
rnorm(n = 1, mean = mm[x, ] %*% parameters.temp[x, ], sd = 30)})
testdata_urbmethod_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
gdd = response, urban = env.samples[,1], method = env.samples[,2]))
testdata_chill_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
chill = response, urban = env.samples[,1], method = env.samples[,2]))
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
library(lme4)
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
modtest
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 650,
urban.coef = -200,
method.coef = 100,
urbanxmethod = 20)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
# Create model matrix
mm <- model.matrix(~env.samples2)
#  4) We need to make a random intercept model for each species
parameters.temp <- matrix(unlist(model.parameters), ncol = length(model.parameters), nrow = nsp * ntot, byrow = TRUE)
# Which parameters are random?
random.regex <- grep(pattern = paste(c("intercept", "urban.coef", "method.coef", "urbanxmethod"), collapse = "|"), x = names(model.parameters))
# Generate random parameters (by species)
parameters.temp[, 1] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[1]]], sd = 100), ntot)})
parameters.temp[, 2] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[2]]], sd = 50), ntot)})
parameters.temp[, 3] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[3]]], sd = 20), ntot)})
parameters.temp[, 4] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[4]]], sd = 10), ntot)})
# Calculate response
response <- sapply(1:nrow(env.samples), FUN = function(x){
rnorm(n = 1, mean = mm[x, ] %*% parameters.temp[x, ], sd = 30)})
testdata_chill_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
chill = response, urban = env.samples[,1], method = env.samples[,2]))
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
modtest
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 650,
urban.coef = -200,
method.coef = 100,
urbanxmethod = 20)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
# Create model matrix
mm <- model.matrix(~env.samples2)
#  4) We need to make a random intercept model for each species
parameters.temp <- matrix(unlist(model.parameters), ncol = length(model.parameters), nrow = nsp * ntot, byrow = TRUE)
# Which parameters are random?
random.regex <- grep(pattern = paste(c("intercept", "urban.coef", "method.coef", "urbanxmethod"), collapse = "|"), x = names(model.parameters))
# Generate random parameters (by species)
parameters.temp[, 1] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[1]]], sd = 75), ntot)})
parameters.temp[, 2] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[2]]], sd = 40), ntot)})
parameters.temp[, 3] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[3]]], sd = 20), ntot)})
parameters.temp[, 4] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[4]]], sd = 10), ntot)})
# Calculate response
response <- sapply(1:nrow(env.samples), FUN = function(x){
rnorm(n = 1, mean = mm[x, ] %*% parameters.temp[x, ], sd = 20)})
testdata_chill_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
chill = response, urban = env.samples[,1], method = env.samples[,2]))
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
modtest
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 650,
urban.coef = -200,
method.coef = 100,
urbanxmethod = -10)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
# Create model matrix
mm <- model.matrix(~env.samples2)
#  4) We need to make a random intercept model for each species
parameters.temp <- matrix(unlist(model.parameters), ncol = length(model.parameters), nrow = nsp * ntot, byrow = TRUE)
# Which parameters are random?
random.regex <- grep(pattern = paste(c("intercept", "urban.coef", "method.coef", "urbanxmethod"), collapse = "|"), x = names(model.parameters))
# Generate random parameters (by species)
parameters.temp[, 1] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[1]]], sd = 75), ntot)})
parameters.temp[, 2] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[2]]], sd = 40), ntot)})
parameters.temp[, 3] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[3]]], sd = 20), ntot)})
parameters.temp[, 4] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[4]]], sd = 5), ntot)})
# Calculate response
response <- sapply(1:nrow(env.samples), FUN = function(x){
rnorm(n = 1, mean = mm[x, ] %*% parameters.temp[x, ], sd = 20)})
testdata_chill_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
chill = response, urban = env.samples[,1], method = env.samples[,2]))
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
modtest
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 650,
urban.coef = -200,
method.coef = 100,
urbanxmethod = -10)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
# Create model matrix
mm <- model.matrix(~env.samples2)
#  4) We need to make a random intercept model for each species
parameters.temp <- matrix(unlist(model.parameters), ncol = length(model.parameters), nrow = nsp * ntot, byrow = TRUE)
# Which parameters are random?
random.regex <- grep(pattern = paste(c("intercept", "urban.coef", "method.coef", "urbanxmethod"), collapse = "|"), x = names(model.parameters))
# Generate random parameters (by species)
parameters.temp[, 1] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[1]]], sd = 50), ntot)})
parameters.temp[, 2] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[2]]], sd = 30), ntot)})
parameters.temp[, 3] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[3]]], sd = 10), ntot)})
parameters.temp[, 4] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[4]]], sd = 5), ntot)})
# Calculate response
response <- sapply(1:nrow(env.samples), FUN = function(x){
rnorm(n = 1, mean = mm[x, ] %*% parameters.temp[x, ], sd = 20)})
testdata_chill_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
chill = response, urban = env.samples[,1], method = env.samples[,2]))
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
modtest
write.csv(testdata_chill_intrxn, file="output/testdata_chill_intrxn.csv", row.names = FALSE)
# housekeeping
rm(list=ls())
options(stringsAsFactors = FALSE)
#### Questions to address:
## Compare GDDs between hobo loggers and weather station data
# 1) GDDlo ~ 1 + (1|species) - do once for HF weather station, once for hobo logger and repeat for Arboretum
# Compare urban effect using weather station data and then hobo logger data
# 2) GDDlo ~ urban + (urban|species) - do once with weather station data and once with hobo logger data
## Let's start with Question 1 first...
library(shinystan)
library(rstan)
## Let's load some real data to check out.
setwd("~/Documents/git/microclimates/analyses/")
chill <- read.csv("output/testdata_chill_intrxn.csv")
datalist.chill <- with(chill,
list(y = chill,
urban = urban,
method = method,
sp = as.numeric(as.factor(species)),
N = nrow(urb),
n_sp = length(unique(species))
)
)
datalist.chill <- with(chill,
list(y = chill,
urban = urban,
method = method,
sp = as.numeric(as.factor(species)),
N = nrow(chill),
n_sp = length(unique(species))
)
)
chill_fake_intrxn = stan('stan/chill_normal_ncp_inter.stan', data = datalist.gdd,
iter = 2000, warmup=1000)#, control=list(adapt_delta=0.99)) ###
chill_fake_intrxn = stan('stan/chill_normal_ncp_inter.stan', data = datalist.chill,
iter = 2000, warmup=1000)#, control=list(adapt_delta=0.99)) ###
chilling <- read.csv("output/testdata_chill_intrxn.csv")
datalist.chill <- with(chilling,
list(y = chill,
urban = urban,
method = method,
sp = as.numeric(as.factor(species)),
N = nrow(chilling),
n_sp = length(unique(species))
)
)
chill_fake_intrxn = stan('stan/chill_normal_ncp_inter.stan', data = datalist.chill,
iter = 2000, warmup=1000)#, control=list(adapt_delta=0.99)) ###
chill_fakesum <- summary(chill_fake_intrxn)$summary
chill_fakesum[grep("mu_", rownames(chill_fakesum)),]
chill_fakesum[grep("sigma_", rownames(chill_fakesum)),]
yraw <- chill$chill
launch_shinystan(chill_fake_intrxn)
############################################################################
########################## Real data chilling ##############################
############################################################################
ws <- read.csv("output/clean_gdd_chill_bbanddvr.csv")
ws$method <- 1
ws_urb <- subset(ws, select=c("id", "type", "gdd_bb", "method", "year", "genus", "species", "utah"))
ws_urb <- ws_urb[(ws_urb$type!="Common Garden"),]
hobo <- read.csv("output/clean_gdd_chill_bbanddvr_hobo.csv")
hobo$method <- 0
hobo_urb <- subset(hobo, select=c("id", "type", "gdd_bb", "method", "year", "genus", "species", "utah"))
hobo_urb <- hobo_urb[(hobo_urb$type!="Common Garden"),]
bball <- dplyr::full_join(ws_urb, hobo_urb)
bball$urban <- NA
bball$urban <- ifelse(bball$type=="Harvard Forest", 0, bball$urban)
bball$urban <- ifelse(bball$type=="Treespotters", 1, bball$urban)
bball.stan <- bball[(bball$year=="2019"),]
bball.stan <- subset(bball, select=c(utah, urban, method, genus, species))
bball.stan <- bball.stan[(complete.cases(bball.stan)),]
bball.stan <- bball.stan[!is.na(bball.stan$gdd_bb),]
bball.stan$spp <- paste(bball.stan$genus, bball.stan$species, sep="_")
yraw <- bball$utah
yraw <- na.omit(yraw)
datalist.chill <- with(bball.stan,
list(y = utah,
urban = urban,
method = method,
sp = as.numeric(as.factor(spp)),
N = nrow(bball.stan),
n_sp = length(unique(bball.stan$spp))
)
)
chillmod = stan('stan/chill_normal_ncp_inter.stan', data = datalist.chill,
iter = 4000, warmup=2500, control=list(adapt_delta=0.90)) ###
bball.stan <- bball[(bball$year=="2019"),]
bball.stan <- subset(bball, select=c(utah, urban, method, genus, species))
bball.stan <- bball.stan[(complete.cases(bball.stan)),]
bball.stan <- bball.stan[!is.na(bball.stan$gdd_bb),]
bball.stan <- bball[(bball$year=="2019"),]
bball.stan <- subset(bball, select=c(utah, urban, method, genus, species))
bball.stan <- bball.stan[(complete.cases(bball.stan)),]
bball.stan <- bball.stan[!is.na(bball.stan$utah),]
bball.stan$spp <- paste(bball.stan$genus, bball.stan$species, sep="_")
yraw <- bball$utah
yraw <- na.omit(yraw)
datalist.chill <- with(bball.stan,
list(y = utah,
urban = urban,
method = method,
sp = as.numeric(as.factor(spp)),
N = nrow(bball.stan),
n_sp = length(unique(bball.stan$spp))
)
)
chillmod = stan('stan/chill_normal_ncp_inter.stan', data = datalist.chill,
iter = 4000, warmup=2500, control=list(adapt_delta=0.90)) ###
chillmod_sum <- summary(chillmod)$summary
chillmod_sum[grep("mu_", rownames(chillmod_sum)),]
chillmod_sum[grep("sigma_", rownames(chillmod_sum)),]
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 650,
urban.coef = 800,
method.coef = -200,
urbanxmethod = -10)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
# Create model matrix
mm <- model.matrix(~env.samples2)
#  4) We need to make a random intercept model for each species
parameters.temp <- matrix(unlist(model.parameters), ncol = length(model.parameters), nrow = nsp * ntot, byrow = TRUE)
# Which parameters are random?
random.regex <- grep(pattern = paste(c("intercept", "urban.coef", "method.coef", "urbanxmethod"), collapse = "|"), x = names(model.parameters))
# Generate random parameters (by species)
parameters.temp[, 1] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[1]]], sd = 100), ntot)})
parameters.temp[, 2] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[2]]], sd = 40), ntot)})
parameters.temp[, 3] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[3]]], sd = 150), ntot)})
parameters.temp[, 4] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[4]]], sd = 10), ntot)})
# Calculate response
response <- sapply(1:nrow(env.samples), FUN = function(x){
rnorm(n = 1, mean = mm[x, ] %*% parameters.temp[x, ], sd = 600)})
testdata_chill_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
chill = response, urban = env.samples[,1], method = env.samples[,2]))
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
modtest
nsp = 20 # number of species
ntot = 200 # numbers of obs per species.
sample_a <- list(urban.env = rbinom(1000, 1, 0.5),
method.env = rbinom(1000, 1, 0.5))
model.parameters <- list(intercept = 650,
urban.coef = 800,
method.coef = -150,
urbanxmethod = -30)
#  2) Now, we will make varying intercepts
env.samples <- sapply(sample_a, FUN = function(x){
sample(x, size = nsp * ntot, replace = TRUE)})
# Determine which environmental variables interact
intrxnname <- names(model.parameters)[4] # interaction terms
names.temp <- gsub("x", "|", intrxnname) # remove text to align with colnames
env.pairs <- sapply(1:length(names.temp), FUN = function(X){
grep(pattern = names.temp[X], x = colnames(env.samples))
})
# Add these interactions (product) to env.samples
env.interactions <- sapply(1:ncol(env.pairs), FUN = function(X){
apply(env.samples[, env.pairs[, X]], MARGIN = 1, FUN = prod)
})
env.samples2 <- cbind(env.samples, env.interactions)
# Create model matrix
mm <- model.matrix(~env.samples2)
#  4) We need to make a random intercept model for each species
parameters.temp <- matrix(unlist(model.parameters), ncol = length(model.parameters), nrow = nsp * ntot, byrow = TRUE)
# Which parameters are random?
random.regex <- grep(pattern = paste(c("intercept", "urban.coef", "method.coef", "urbanxmethod"), collapse = "|"), x = names(model.parameters))
# Generate random parameters (by species)
parameters.temp[, 1] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[1]]], sd = 150), ntot)})
parameters.temp[, 2] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[2]]], sd = 50), ntot)})
parameters.temp[, 3] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[3]]], sd = 150), ntot)})
parameters.temp[, 4] <- sapply(1:nsp, FUN = function(x){
rep(rnorm(n = 1, mean = model.parameters[[random.regex[4]]], sd = 50), ntot)})
# Calculate response
response <- sapply(1:nrow(env.samples), FUN = function(x){
rnorm(n = 1, mean = mm[x, ] %*% parameters.temp[x, ], sd = 600)})
testdata_chill_intrxn <- cbind(data.frame(species = as.vector(sapply(1:nsp, FUN = function(x) rep(x, ntot))),
chill = response, urban = env.samples[,1], method = env.samples[,2]))
#  7) Let's do a quick lmer model to test the fake data
modtest <- lmer(chill ~ urban + method + urban*method + (urban + method + urban*method|species), data=testdata_chill_intrxn) ## Quick look looks good!
modtest
chillmod = stan('stan/chill_normal_ncp_inter.stan', data = datalist.chill,
iter = 4000, warmup=2500, control=list(adapt_delta=0.90)) ###
chillmod_sum <- summary(chillmod)$summary
chillmod_sum[grep("mu_", rownames(chillmod_sum)),]
chillmod_sum[grep("sigma_", rownames(chillmod_sum)),]
############################################################################
chillurb <- brm(utah ~ urban + (urban | species), data=bball)
chillurb
# 2) Does more chilling mean less forcing is needed ?
chillgdd <- brm(gdd_bb ~ utah + (utah | species), data=bball)
chillgdd
View(bball)
View(bball)
# 2) Does more chilling mean less forcing is needed ?
bballchill <- bball[(complete.cases(bball)),]
View(bballchill)
chillgdd <- brm(gdd_bb ~ utah + (utah | species), data=bballchill)
chillgdd
